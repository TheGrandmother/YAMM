values
  subs_per_step: Ticks = 128
types

  Ticks = nat; -- Midi Pulses
  TimeStamp ::
    step : nat
    sub: nat
  inv mk_TimeStamp(-, sub) == sub < subs_per_step
  ord t1 < t2 == t1.step < t2.step or t1.step = t2.step and t1.sub < t2.sub
  ; 

  MidiMessage = token;
  Event :: msg : MidiMessage ts: TimeStamp;
  Sequence = set of Event;
  State = <playing> | <stop>;
  -- Division = <whole> | <half> | <quarter>| <eigth>| <sixtenth>

  state Player of
    length: nat
    ts: TimeStamp
    clock: Ticks
    pps: Ticks -- Pulses per step
    sequence: Sequence
    player_state: State
  inv p == p.ts.step < p.length
  end

operations

TICK() emitted: set of Event
ext wr clock : Ticks
    wr ts: TimeStamp
    rd sequence : Sequence
    rd player_state : State
post
  cases player_state:
    <playing> -> (
      clock = clock~ + 1 and
      ts = get_ts() and
      emitted = get_emitted(ts~, ts)
    ),
    <playing> -> (
      clock = clock~ and
      ts = ts~ and
      emitted = {}
    )
  end
;

START()
ext wr player_state : State
post
  player_state = <playing>
;

STOP()
ext wr player_state : State
    wr clock : Ticks
    wr ts : TimeStamp
post
  player_state = <stop> and clock = 0 and ts = mk_TimeStamp(0,0)
;

pure get_ts() new_ts: TimeStamp
post
  (new_ts.step = (clock / pps) rem length) and
  (new_ts.sub = ((clock rem pps) * subs_per_step / pps))
;

pure get_emitted(old_ts: TimeStamp, new_ts: TimeStamp) emitted: set of Event
pre old_ts <= new_ts
post
  forall e in set sequence & (e.ts > old_ts and e.ts <= new_ts) => e in set emitted
;

functions

get_pps(divisor: nat, ppq: Ticks) pps: Ticks
post pps = ppq * divisor*4;
