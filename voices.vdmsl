module Voices
exports all
definitions
types
  Channel = nat
  inv c == c < 4
  ;
  Timestamp = nat;
  MidiEvent :: channel : nat type : token;

  Port = token;

  Config :: channels: set of Channel
            drum_channel: Channel
            port_mappings: map Channel to set of Port --maps channel to ports
            vel_mappings: map Port to Port --maps ports to vel pair
            aftertouch: [Port]
            legato: bool
  inv c ==
    c.drum_channel not in set c.channels and
    dom c.port_mappings = c.channels and
    dom c.vel_mappings = dunion rng c.port_mappings and
    rng c.vel_mappings \ dunion rng c.port_mappings = {}
  ;

  TrackedMessage ::  msg: MidiEvent
                    ts: nat
                    port: Port
  ord m1 < m2 == m1.ts < m2.ts 
  ;

  Output = token;

  state Voices of
    config : Config
    active_messages : set of TrackedMessage
  end;

operations
  RECEIVE(e: MidiEvent)
  ext wr active_messages : set of TrackedMessage
      rd config : Config
  post not(e.channel in set config.channels or e.channel = config.drum_channel) => active_messages = active_messages~;

functions

remove_oldest(msgs: set of TrackedMessage) new_msgs : set of TrackedMessage
post
  msgs <> {} => card new_msgs < card msgs and
  exists msg in set msgs & msg not in set new_msgs and forall msg2 in set new_msgs & msg2 > msg
;


find_oldest_port(msgs: set of TrackedMessage) port : Port
post
  exists oldest_msg in set msgs &
    port = oldest_msg.port and
    forall msg in set msgs & msg <> oldest_msg => oldest_msg < msg
;

end Voices
